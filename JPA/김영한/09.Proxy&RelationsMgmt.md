
1. 프록시
1.1. 개념
* JPA는 엔티티가 실제 사용될 때까지 DB 조회를 지연하는 Lazy Loading (지연 로딩)을 지원한다.
* 이를 가능하게 하는 가짜 객체를 프록시 객체라고 한다.
* 프록시 객체는 실제 클래스를 상속 받아 만들어져서 겉모양이 똑같지만, 빈 껍데기이고 실제 객체에 대한 참조 만을 보관한다.

1.2. 프록시 초기화
* 프록시 객체는 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 실제 엔티티 생성을 요청하는데, 이를 초기화라고 한다.
* 실제 엔티티로 프록시가 교체되는 것은 아니고 접근할 수만 있게 해줌.
* 영속성 컨텍스트에 있으면 DB 조회를 하지 않아도 되므로 `em.getReference()`를 호출해도 프록시가 아닌 실제 엔티티가 반환된다.
* 영속성 컨텍스트에서 나와 있는 준영속 상태의 프록시를 초기화하면 에러가 난다.

* 프록시인지 진짜 엔티티인지 확인하려면: 클래스명을 출력했을 때 클래스명 뒤에 `..javassist..`라고 되어 있으면 프록시다.


2. 즉시로딩, 지연로딩
모든 연관관계에 일단 지연 로딩을 사용하고, 개발이 어느 정도 완료되었을 때 실제 사용하는 상황을 보고 꼭 필요한 곳에만 즉시 로딩을 사용하도록 최적화하는 것이 좋음.

2.1. `FetchType.EAGER` 즉시로딩: 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다.
* @ManyToOne, @OneToOne의 기본값
* JPA 구현체는 즉시 로딩을 최적화하기 위해 가능하면 조인 쿼리를 사용한다.
* 참조되는 외래키가 null 일수도 있기 때문에 외부 조인(LEFT OUTER JOIN)을 사용한다.
* 성능과 최적화에 유리한 INNER JOIN을 사용하려면 외래키가 NOT NULL임을 보장해야 한다.
==> `@JoinColumn(name=“TEAM_ID”, nullable=false)`

2.2.  `FetchType.LAZY` 지연로딩: 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법
* @OneToMany, @ManyToMany 의 기본값

3. 영속성 전이: CASCADE
특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함게 영속 상태로 만들고 싶을 때 영속성 전이
JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다.
3.1. `CascadeType.PERSIST`
	* 부모를 영속화할 때 연관된 자식들도 함께 영속화
	* 이때 엔티티를 삭제하려면 각각 따로 다 삭제해줘야 함.
3.2. `CascadeType.REMOVE`
	* 부모를 삭제할 때 자식들도 싹 다 삭제.
	* 외래 키 제약 조건을 고려하여 자식 먼저 삭제하고 부모 삭제.
3.3. MERGE, REFRESH...


4. 고아 객체 
부모 엔티티와의 연관 관계가 끊어진 자식 엔티티를 자동으로 삭제 ==> 고아 객체 삭제
```
@OneToMany (mappedBy=“parent”, orphanRemoval=true)
Private List<Child> children = new ArrayList<Child>();
```
* 참조하는 곳이 하나일 때에만 사용 가능. 삭제한 엔티티를 다른 곳에서도 참조하고 있으면 문제가 발생함.
==> `@OneToOne`, `@OneToMany` 에서만 사용할 수 있음.
5. 영속성 전이 + 고아 객체, 생명주기
