## 영속성 컨텍스트 (Persistence Context)

1. 엔티티의 생명주기
![](https://t1.daumcdn.net/cfile/tistory/99B7EC375BA131440C)

* 비영속 new / transient : 영속성 컨텍스트와 전혀 관계 없음. 
* 영속 managed : 영속성 컨텍스트에 저장된 상태.
* 준영속 detached : 영속성 컨텍스트에 저장되었다가 분리된 상태.
`em.close()`, `em.clear()` 가 호출되도, 해당 시점에 영속상
* 삭제 removed : 삭제된 상태.

※ save transient object
아니 비영속 상태에 있는 애를 왜 자꾸 flush 전에 저장하라고 난리?

2. 영속성 컨텍스트의 특징
* 식별자 값
엔티티를 식별자 값(`@Id`)으로 구분하기 때문에, 영속 상태에는 식별자 값이 반드시 있어야 한다.
* DB 저장
트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 DB에 반영하는데, 이것을 flush라고 한다.
* 장점
1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기 지연, 변경 감지, 지연 로딩


3. CRUD로 보는 영속성 컨텍스트의 특징
3.1. 조회
영속성 컨텍스트는 내부에 캐시를 갖고 있고, 이를 1차 캐시라고 한다.
`em.find(Member.class,"id")` 를 실행하면
1) 1차 캐시에서 조회
2) 찾는 엔티티가 없으면 DB 에서 조회한 뒤 영속성 컨텍스트에 추가한다.

==>그렇기 때문에 `find`가 반복 호출되어도 **엔티티의 동일성**을 보장한다.
==> JPA는 1차 캐시를 통해 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 DB가 아닌 앱 차원에서 제공한다.

3.2. 등록
```
EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();

tx.begin();
em.persist(A); // 쿼리 발생 X
em.persist(B); // 쿼리 발생 X
tx.commit(); // 쿼리 O
```
엔티티 매니저는 트랜잭션을 커밋하기 직전까지 내부 쿼리 저장소에 INSERT SQL 을 모아둔다.
==> 쓰기 지연을 통해 성능 최적화를 돕는다.

3.3. 수정
* 일반 SQL을 사용하는 경우: update 쿼리를 계속 만들어야 함. 비즈니스 로직이 직/간접적으로 SQL에 의존적일 수밖에 없음.
JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는데 이것을 스냅샷이라고 한다. flush 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다.
단, 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.
==> 변경 감지를 통해 update를 자동으로 처리해준다.

3.4. 삭제
엔티티를 삭제하기 위해서는 먼저 삭제 대상 엔티티를 조회한다.
```
Member memberA = em.find(Member.class, "memberA");
em.remove(memberA);
```
* 다른 쿼리들처럼 트랜잭션이 커밋될 때 한꺼번에 처리된다.
* `remove()`가 호출되는 순간 해당 엔티티는 영속성 컨텍스트에서 제거된다.


4. Flush
영속성 컨텍스트의 변경 내용을 DB에 반영한다.
`flush()`가 호출될 때 다음과 같은 일이 발생한다. 
* 변경 감지 동작 => 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다. 수정 쿼리가 생성되어 지연 SQL 저장소에 저장된다.
* 쿼리 전송 => 쓰기 지연 SQL 저장소의 쿼리가 DB에 전송된다. 

flush 하는 방법은 3가지다.
* `em.flush()`를 직접 호출: 거의 사용하지 않는다.
* `tx.commit()`시 자동 호출
* JPQL 쿼리 실행시: 쿼리 실행 직전에 영속성 컨텍스트를 플러시해서(`persist`나 업데이트된 게 있는 경우, `find`는 해당 안됨) 변경 내용을 DB에 반영한 뒤 쿼리를 실행한다.
