## 부동산 정보 호출하기


Caused by: org.springframework.transaction.UnexpectedRollbackException: Transaction silently rolled back because it has been marked as rollback-only

The possibility of getting this exception in Spring-managed environments is when the transaction propagation is set to REQUIRED:

<tx:method name="do*" propagation="REQUIRED" />
Consider a scenario as this:

Caller -------> [Transactional Method1(m1)] ----------> [Transactional Method2(m2)]

In Spring-managed environments, there is a difference between logical and physical transactions. A logical transaction scope is created for each method upon which this setting is applied. The logical transaction scope for method m1 is different from m2. Each logical transaction can determine its own rollback-only status individually. And with this setting, an outer transaction scope (m1's scope) is logically independent from the inner transaction scope (m2's scope).

But all these scopes are mapped to the same physical transaction. So, if the inner transaction is marked for rollback, it effects the outer transaction's chance to commit (even if there is no exception thrown from the the outer transaction).

Now if there is an exception thrown from inner transaction and it is marked for rollback. But there is no exception thrown from outer transaction, so it has not decided on the rollback itself, and so the rollback (silently triggered by the inner transaction scope) is unexpected. And a corresponding UnexpectedRollbackException is thrown at that point.

So if an inner transaction (of which the outer caller is not aware) silently marks a transaction as rollback-only, the outer caller receives an UnexpectedRollbackException if it still calls commit. This is an indication to the outer caller that a rollback was performed instead of a commit. And this an expected behavior to let the caller of a transaction know that there was an exception and the the transaction was rolled back.






Without having your code, I have to guess, I believe it has to do with the overhead of creating new transaction for each object saved in the case of save versus opening one transaction in the case of saveAll.

Notice the definition of save and saveAll they are both annotated with @Transactional. If your project is configured properly, which seems to be the case since entities are being saved to the database, that means a transaction will be created whenever one of these methods are called. if you are calling save in a loop that means a new transaction is being created each time you call save, but in the case of saveAll there is one call and therefor one transaction created regardless of the number of entities being saved.

I'm assuming that the test is not itself being run within a transaction, if it were to be run within a transaction then all calls to save will run within that transaction since the the default transaction propagation is Propagation.REQUIRED, that means if there is a transaction already open the calls will be run within it. If your planning to use spring data I strongly recommend that you read about transaction management in Spring.


기본키 자동생성 방법 
IDENTITY : 기본 키 생성을 데이터베이스에 위임하는 방법 (데이터베이스에 의존적)
- 주로 MySQL, PostgresSQL, SQL Server, DB2에서 사용합니다.
SEQUENCE : 데이터베이스 시퀀스를 사용해서 기본 키를 할당하는 방법 (데이터베이스에 의존적)
- 주로 시퀀스를 지원하는 Oracle, PostgresSQL, DB2, H2에서 사용합니다. 
- @SequenceGenerator를 사용하여 시퀀스 생성기를 등록하고, 실제 데이터베이스의 생성될 시퀀스이름을 지정해줘야 합니다.
TABLE : 키 생성 테이블을 사용하는 방법
- 키 생성 전용 테이블을 하나 만들고 여기에 이름과 값으로 사용할 컬럼을 만드는 방법입니다.
- 테이블을 사용하므로, 데이터베이스 벤더에 상관없이 모든 데이터베이스에 적용이 가능합니다.
AUTO : 데이터베이스 벤더에 의존하지 않고, 데이터베이스는 기본키를 할당하는 벙법
- 데이터베이스에 따라서 IDENTITY, SEQUENCE, TABLE 방법 중 하나를 자동으로 선택해주는 방법입니다.
- 예를들어, Oracle일 경우 SEQUENCE를 자동으로 선택해서 사용합니다. 따라서, 데이터베이스를 변경해도 코드를 수정할 필요가 없습니다.


출처: https://ithub.tistory.com/24 [Fall in IT.]