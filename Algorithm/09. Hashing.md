
## 해시 테이블이란
해시 테이블은 dynamic set을 구현하는 효과적인 방법 중 하나.
적절한 가정 하에 평균 탐색, 삽입, 삭제 시간은 O(1)
최악의 경우 O(n)

해시 테이블
해시 함수 h를 사용해서 키를 T[h(k)]에 저장
키 k가 h(k)로 해싱되었다고 함.
각 키에 대한 해시함수값을 그 키를 저장할 배열의 인덱스로 사용.


## 충돌
두 개 이상의 키가 동일한 위치로 해싱되는 경우
==> 해결 방법 1) chaining 2) open addressing

1. Chaining
최악의 경우 모든 키가 하나의 슬롯으로 해싱되는 경우,
길이가 n인 하나의 연결리스트가 만들어짐.
따라서 최악의 경우 탐색시간은 O(n) + 해시함수 계산시간
==> 키들이 여러 슬롯에 얼마나 잘 분배되느냐에 의해서 평균시간복잡도가 결정됨.

1) 삽입
키 k를 리스트 T[h(k)]의 맨 앞에 삽입: O(1)
중복된 키가 들어올 수 있고, 중복 저장은 허용되지 않는다면 삽입시 리스트를 검색해야 함 --> 시간복잡도는 리스트의 길이에 비례

2) 검색
리스트 T[h(k)]에서 순차검색
시간복잡도는 키가 저장된 리스트의 길이에 비례.

3) 삭제
리스트 T[h(k)]로부터 키를 검색한 후 삭제
일단 키를 검색해서 찾은 후에는 O(1) 시간 내에 삭제 가능.


* SUHA (Simple Uniform Hashing Information)
각각의 키가 모든 슬롯에 균등한 확률로 독립적이게 해싱된다는 가정.
현실에서는 불가능하지만 성능분석을 위해 주로 하는 가정임.


2. Open Addressing
모든 키를 해시 테이블 자체에 저장
테이블의 각 칸에는 한 개의 키만 저장
충돌해결기법: 1) Linear probing 2) Quadratic probing 3) Double hashing

1) Linear probing
원래 넣어야 하는 칸이 풀찼으면 그 다음 빈 슬롯에 넣는다.

단점
원래 입력되었어야 하는 슬롯에서 멀리 떨어지는 애들(클러스터)이 많아짐.

2) Quadratic probing 
h(k), h(k)+1^2, h(k)+2^2, h(k)+3^2,... 이런 식으로 인덱스 할당

3) Double hashing
해싱 함수가 두 개인 것.
h1(k) = k mod 13
h2(k) = 1 + (k mod 11)


* 삭제 연산
중간에 있는 키가 삭제가 되면, 그 다음에 있는 키를 검색할 때 값이 있음에도 못 찾는다고(빈 공간이 나왔으니까) 할 수 있음.


## 
1. 좋은 해시 함수란?
키들이 어떤 특정한 패턴을 가지더라도 해시함수값이 불규칙적으로 나오도록 만들어야 함 => 해시함수 값이 키의 특정 부분에 의해서만 결정되지 않아야 함.
